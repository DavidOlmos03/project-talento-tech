# -*- coding: utf-8 -*-
"""limpieza_y_calculo_de_potencial_eolico.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lOqTg-KYBkzaNrPh44REWEkUEU5mpcd1
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from google.colab import drive
from scipy.stats import weibull_min
from google.colab import files
drive.mount('/content/drive')

"""## **CARGA Y ORDENAMIENTO DE LOS DATOS**

---


"""

data_completa =  '/content/drive/My Drive/eolicos manizales/sensores/18.csv'
bd_completa = pd.read_csv(data_completa)
bd_completa

#SE PASA LAS COLUMNAS DE  FECHA Y TIEMPO A UNA NUEVA LLAMADA REGISTRO DONDE SE PASA A UN ODJETO DE DATA-TIME

bd_completa['registro'] = pd.to_datetime(bd_completa['fecha']+' '+bd_completa['tiempo'])
bd_completa.set_index('registro', inplace = True)
bd_completa.drop(['fecha', 'tiempo'], axis = 1, inplace = True)
bd_completa

"""## **ANALISI DE LA BASE DE DATOS**

---


"""

#VISTA PREVIA DE VALORES FALTANTES

for i in range(2019,2025,1):
    print(f'datos_faltantes {i}:',bd_completa.loc[str(i)].isnull().sum())
    print('totel:',len(bd_completa.loc[str(i)]))

#PORCENTAJE DE VALORES FALTANTES
porcentaje_faltante = bd_completa.isnull().mean() * 100
print(porcentaje_faltante)

#DADO QUE SABEMOS QUE HAY UN CONSIDERABLE FALTA DE DATOS, ENTONCES LOS MAPEAMOS
import missingno as msno
msno.matrix(bd_completa)

#ES NECESARIO AVERIGUAR LA CORRELACION

import missingno as msno

msno.heatmap(bd_completa)

"""## **IMPUTACION**

---


"""

bd_completa.interpolate(method='linear', inplace=True)
bd_completa.loc['2019-01'].mean()

bd_completa.isnull().sum()

#PROMEDIOS POR DIA
sensor_18_diarios = bd_completa.resample('D').mean()
sensor_18_diarios.isnull().sum()

sensor_18_diarios.interpolate(method='linear', inplace=True)
sensor_18_diarios.isnull().sum()

sensor_18_diarios.loc['2019']

"""## **POTENCIAL EOLICO**

---


"""

#hay datos desde 2019 hasta mediados de 2024 por lo que el analisis deberia ser de cada año descartando el año 2024
from scipy.special import gamma
for año in range(2019,2024,1):
    data = sensor_18_diarios.loc[str(año)]
    #calculo cuartiles para descartar periodos de calma y periodos de rafagas fuertes
    print('IQR NORMALIZACION')
    Q1 = data['velocidad_viento'].quantile(0.25)
    Q3 = data['velocidad_viento'].quantile(0.75)
    IQR = Q3-Q1

    print('PRIMER CUARTIL = ',Q1)
    print('TERCER CUARTIL = ',Q3)
    print('IQR = ', IQR)

        #DEFINICION DE LIMITES
    limite_inf = Q1 -1.5*IQR
    limite_sup = Q3 + 1.5*IQR

    print('limite superio',limite_sup)
    print('limite inferior',limite_inf)

        #SELECCION DE VALORES
    data_filtro = data[(data['velocidad_viento']>= limite_inf)&
                                                (data['velocidad_viento']<=limite_sup)]

    print('POTENCIAL EOLICO')
    #potencial eolico
    print(f'potencial eolico para {año}')
    print('medias:',data_filtro.mean())
    viento = np.array(data_filtro['velocidad_viento'])


    #ajuste de weibull
    params = weibull_min.fit(viento,floc = 0)  #ajuste de la distribucion
    k,loc,lambda_ = params

    #calculo de v^3
    E_v3 = lambda_ **3*gamma(1+ 3/k)

    #densidad del aire promedio  (efectos simplistas) la asumimos como rho = 1.225

    rho = 1.225
    energia_prom = 0.5*rho*E_v3

    print(f"Parámetro k: {k}")
    print(f"Parámetro lambda: {lambda_}")
    print(f"Densidad de energía eólica promedio: {energia_prom} W/m²")

    # 4. Graficar la distribución de Weibull ajustada y los datos de velocidad del viento
    x = np.linspace(0, np.max(viento), 100)
    y = weibull_min.pdf(x, k, loc, lambda_)

    plt.plot(x, y, label="Distribución de Weibull ajustada")
    plt.hist(viento, bins=30, density=True, alpha=0.6, color='g', label="Datos de viento")
    plt.legend()
    plt.xlabel("Velocidad del viento (m/s)")
    plt.ylabel("Densidad de probabilidad")
    plt.title("Distribución de Weibull ajustada a los datos de viento")
    plt.show()

"""## **PERFIL VERTICAL**

---


"""

h1 = 2  # Altura original
h2 = 30  # Altura  ODJETIVO
alpha = 0.14  # Exponente para la ley de potencia

# Calcular la velocidad del viento a 20 m (si los datos están a 10 m)
sensor_18_diarios['velocidad_viento_30m'] = sensor_18_diarios['velocidad_viento'] * (h2 / h1) ** alpha


sensor_18_diarios

#hay datos desde 2019 hasta mediados de 2024 por lo que el analisis deberia ser de cada año descartando el año 2024
from scipy.special import gamma
for año in range(2019,2024,1):
    data = sensor_18_diarios.loc[str(año)]
    #calculo cuartiles para descartar periodos de calma y periodos de rafagas fuertes
    print('IQR NORMALIZACION')
    Q1 = data['velocidad_viento_30m'].quantile(0.25)
    Q3 = data['velocidad_viento_30m'].quantile(0.75)
    IQR = Q3-Q1

    print('PRIMER CUARTIL = ',Q1)
    print('TERCER CUARTIL = ',Q3)
    print('IQR = ', IQR)

        #DEFINICION DE LIMITES
    limite_inf = Q1 -1.5*IQR
    limite_sup = Q3 + 1.5*IQR

    print('limite superio',limite_sup)
    print('limite inferior',limite_inf)

        #SELECCION DE VALORES
    data_filtro = data[(data['velocidad_viento_30m']>= limite_inf)&
                                                (data['velocidad_viento_30m']<=limite_sup)]

    print('POTENCIAL EOLICO')
    #potencial eolico
    print(f'potencial eolico para {año}')
    print('medias:',data_filtro.mean())
    viento = np.array(data_filtro['velocidad_viento_30m'])


    #ajuste de weibull
    params = weibull_min.fit(viento,floc = 0)  #ajuste de la distribucion
    k,loc,lambda_ = params

    #calculo de v^3
    E_v3 = lambda_ **3*gamma(1+ 3/k)

    #densidad del aire promedio  (efectos simplistas) la asumimos como rho = 1.225

    rho = 1.225
    energia_prom = 0.5*rho*E_v3

    print(f"Parámetro k: {k}")
    print(f"Parámetro lambda: {lambda_}")
    print(f"Densidad de energía eólica promedio: {energia_prom} W/m²")

    # 4. Graficar la distribución de Weibull ajustada y los datos de velocidad del viento
    x = np.linspace(0, np.max(viento), 100)
    y = weibull_min.pdf(x, k, loc, lambda_)

    plt.plot(x, y, label="Distribución de Weibull ajustada")
    plt.hist(viento, bins=30, density=True, alpha=0.6, color='g', label="Datos de viento")
    plt.legend()
    plt.xlabel("Velocidad del viento (m/s)")
    plt.ylabel("Densidad de probabilidad")
    plt.title("Distribución de Weibull ajustada a los datos de viento")
    plt.show()

!pip install pycaret

sensor_18_diarios